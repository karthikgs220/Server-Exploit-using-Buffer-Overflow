# Server-Exploit-using-Buffer-Overflow

This will analyse some server code for vulnerabilities and remotely exploit those vulnerabilities to take over the server's host machine.
A successful buffer overflow attack allows the execution of arbitrary code of an attacker’s choosing.

Often, an attacker would like to launch a command interpreter (aka a shell), that way he/she obtains full control of the host machine
(especially if the victim process runs with elevated privileges)

The attacker writes some C code which does what she needs

Her program will call the C library function execve which sets up for and invokes the underlying execve system call

He/She disassembles the program to see what is going on in the background and to view the machine executable opcodes that are required to implement the attack

Clearly her exploit must invoke the same system call: this requires building the necessary data structure on the stack, initialising some registers and executing a software interrupt to jump to the kernel’s system call handling code

The exploit code will not make a library call (who knows where it is in the victim process address space) and instead invokes the system call directly

What does the attacker need to do?

1. Have the null terminated /bin/sh string in memory

2. Have the address of the /bin/sh string in memory

3. Have the latter address followed by a null in memory

4. Put 0xb in the eax register

5. Put the address of the /bin/sh string in the ebx register

6. Put the address of the address of the /bin/sh string in the ecx register

7. Put null in the edx register

8. Execute the 0x80 software interrupt

This exploit program takes two parameters:

1. The length of the string to inject

2. An offset used in new return address calculation

The attacker wants to overwrite a return address in the vulnerable
program with a new one that points into a buffer on the stack - but
where will that buffer be in memory?

If we assume (it is an assumption as the loader chooses a random
stack start address) that on execlp the child process inherits a
stack start address similar to its parent then that might be a good
place to start

We can inline some assembly in the exploit program to gather the
relevant information:

static unsigned int getesp(void) {
__asm__("movl %esp,%eax");
}

Calling the above function in the exploit program will give a rough
idea of where the stack will begin in the vulnerable program (to be
invoked through a call to execlp)

Subtracting the user-supplied command line offset from this value
gives a new target return address (some thought is usually
required to come up with a suitable offset)

Finally, the gathered information is used to build the attack string
and it is passed to the vulnerable program with a call to execlp

The server:
A remote, multithreaded server is listening on port 8001. You know the following:

The server was built on and is executing on a 32-bit x86 machine running the same Linux distribution as the CA647 virtual machine
Address space randomisation is enabled

The No eXecute (NX) feature is disabled

The server was built with gcc version 3 (same version as installed in the CA647 virtual machine) as follows:

gcc -mpreferred-stack-boundary=2 -march=i386 -o ca647_server ca647_server.c -lpthread

A client connects to the server and sends its name whereupon the server displays the date or time depending on the client's selection. 


